From f2c56053b63de84e9aa913ea18a02e5f753f49ce Mon Sep 17 00:00:00 2001
From: zaixiang xu <zaixiang.xu@transsion.com>
Date: Tue, 26 Aug 2025 08:44:42 -0700
Subject: [PATCH] Optimize the display speed of desktop icons when switching
 icon styles

Change the icon from single-threaded serial loading to multi-threaded loading (put into task queue)

Bug: 442273512
Test: Test icon loading speed
Change-Id: Ief1bba5394a6cd453ef7543cd5ee99f7265087af
---
 .../android/launcher3/icons/IconCache.java    |  53 +++++---
 .../android/launcher3/util/TaskSchedule.java  | 128 ++++++++++++++++++
 2 files changed, 159 insertions(+), 22 deletions(-)
 create mode 100644 src/com/android/launcher3/util/TaskSchedule.java

diff --git a/src/com/android/launcher3/icons/IconCache.java b/src/com/android/launcher3/icons/IconCache.java
index 1e80d03727..076e2306fe 100644
--- a/src/com/android/launcher3/icons/IconCache.java
+++ b/src/com/android/launcher3/icons/IconCache.java
@@ -73,7 +73,10 @@ import com.android.launcher3.util.InstantAppResolver;
 import com.android.launcher3.util.PackageUserKey;
 import com.android.launcher3.widget.WidgetSections;
 import com.android.launcher3.widget.WidgetSections.WidgetSection;
+import com.android.launcher3.util.Executors;
+import com.android.launcher3.util.TaskSchedule;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -489,6 +492,7 @@ public class IconCache extends BaseIconCache {
         }
 
         Trace.beginSection("loadIconSubsectionWithFallback");
+        ArrayList<TaskSchedule.SafelyRunnable> tasksList = new ArrayList<>();
         // Fallback title and icon loading
         for (ComponentName cn : duplicateIconRequestsMap.keySet()) {
             IconRequestInfo<T> iconRequestInfo = duplicateIconRequestsMap.get(cn).get(0);
@@ -513,30 +517,35 @@ public class IconCache extends BaseIconCache {
                     entry.bitmap = icon;
                 }
                 entry.contentDescription = itemInfo.contentDescription;
-
-                if (loadFallbackIcon) {
-                    loadFallbackIcon(
-                            lai,
-                            entry,
-                            LauncherActivityCachingLogic.INSTANCE,
-                            /* usePackageIcon= */ false,
-                            /* usePackageTitle= */ loadFallbackTitle,
-                            cn,
-                            sectionKey.first);
-                }
-                if (loadFallbackTitle && TextUtils.isEmpty(entry.title) && lai != null) {
-                    loadFallbackTitle(
-                            lai,
-                            entry,
-                            LauncherActivityCachingLogic.INSTANCE,
-                            sectionKey.first);
-                }
-
-                for (IconRequestInfo<T> iconRequest : duplicateIconRequestsMap.get(cn)) {
-                    applyCacheEntry(entry, iconRequest.itemInfo);
-                }
+                TaskSchedule.SafelyRunnable runnable = new TaskSchedule.SafelyRunnable() {
+                    @Override
+                    public void onTaskRun() {
+                        if(loadFallbackIcon){
+                            loadFallbackIcon(
+                                    lai,
+                                    entry,
+                                    LauncherActivityCachingLogic.INSTANCE,
+                                    /* usePackageIcon= */ false,
+                                    /* usePackageTitle= */ loadFallbackTitle,
+                                    cn,
+                                    sectionKey.first);
+                        }
+                        if(loadFallbackTitle &&TextUtils.isEmpty(entry.title)&&lai !=null){
+                            loadFallbackTitle(
+                                    lai,
+                                    entry,
+                                    LauncherActivityCachingLogic.INSTANCE,
+                                    sectionKey.first);
+                        }
+                        for(IconRequestInfo<T> iconRequest :duplicateIconRequestsMap.get(cn)){
+                            applyCacheEntry(entry, iconRequest.itemInfo);
+                        }
+                    }
+                };
+                tasksList.add(runnable);
             }
         }
+        TaskSchedule.runTasks(tasksList, Executors.THREAD_POOL_EXECUTOR, Math.max(Runtime.getRuntime().availableProcessors() / 2, 2), 2000);
         Trace.endSection();
     }
 
diff --git a/src/com/android/launcher3/util/TaskSchedule.java b/src/com/android/launcher3/util/TaskSchedule.java
new file mode 100644
index 0000000000..b0b6eb77a3
--- /dev/null
+++ b/src/com/android/launcher3/util/TaskSchedule.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.launcher3.util;
+
+import android.os.SystemClock;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.concurrent.Executor;
+
+public class TaskSchedule {
+
+    static final String TAG = "TaskSchedule";
+    public static void runAllTasksInExecutor(ArrayList<SafelyRunnable> runnableList, Executor executor, int parallelTasks) {
+        int taskSize = runnableList.size();
+        parallelTasks = Math.min(taskSize, parallelTasks);
+        Object LOCK = new Object();
+        for (int i = 0; i < parallelTasks; ++i) {
+            executor.execute(() -> {
+                while (true) {
+                    SafelyRunnable runnable = getTask(runnableList, LOCK);
+                    if (runnable == null) {
+                        break;
+                    }
+                    runnable.run();
+                }
+            });
+        }
+    }
+
+    public static void runTasks(ArrayList<SafelyRunnable> runnableList, Executor executor, int parallelTasks, long timeOut) {
+        int taskSize = runnableList.size();
+        parallelTasks = Math.min(taskSize - 1, parallelTasks);
+        Object LOCK = new Object();
+        final IntCounter intCounter = new IntCounter();
+        for (int i = 0; i < parallelTasks; ++i) {
+            executor.execute(() -> {
+                while (true) {
+                    SafelyRunnable runnable = getTask(runnableList, LOCK);
+                    if (runnable == null) {
+                        break;
+                    }
+                    runnable.run();
+                    synchronized (LOCK) {
+                        intCounter.add();
+                    }
+                }
+            });
+        }
+        long taskDoneTime = -1;
+        while (true) {
+            SafelyRunnable runnable = getTask(runnableList, LOCK);
+            if (runnable == null) {
+                if (intCounter.isEqual(taskSize)) {
+                    break;
+                }
+                if (taskDoneTime == -1) {
+                    taskDoneTime = SystemClock.uptimeMillis();
+                }
+                try {
+                    Thread.sleep(10);
+                } catch (InterruptedException e) {
+                    Log.e(TAG, "InterruptedException-e:" + e.getMessage());
+                }
+                long now = SystemClock.uptimeMillis();
+                if (now - taskDoneTime > timeOut) {
+                    Log.e(TAG, "runTasks>>>>>>>>>>>>>>>>>>>>>>>time out");
+                    break;
+                }
+                continue;
+            }
+            runnable.run();
+            synchronized (LOCK) {
+                intCounter.add();
+            }
+        }
+    }
+
+    static SafelyRunnable getTask(ArrayList<SafelyRunnable> runnableList, final Object LOCK) {
+        synchronized (LOCK) {
+            if (runnableList.isEmpty()) {
+                return null;
+            }
+            int size = runnableList.size();
+            return runnableList.remove(size - 1);
+        }
+    }
+
+    public static abstract class SafelyRunnable implements Runnable {
+
+        @Override
+        public final void run() {
+            try {
+                onTaskRun();
+            } catch (Throwable e) {
+                Log.e(TAG,"SafelyRunnable-Throwable:" + e.getMessage());
+            }
+        }
+
+        public abstract void onTaskRun();
+    }
+
+    public static class IntCounter {
+        public int mCounter = 0;
+
+        public void add() {
+            this.mCounter += 1;
+        }
+
+        public boolean isEqual(int value) {
+            return this.mCounter == value;
+        }
+    }
+}
\ No newline at end of file
-- 
2.47.1.windows.1

